<!DOCTYPE HTML>
<!--
	Forty by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Richmond's Portfolio</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<link href="assets/css/lightbox.css" rel="stylesheet" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>

		<link rel="preload" href="images/Velociraptor/velociraptor.png" as="image">
		<link rel="preload" href="images/Velociraptor/velociraptor_closeup.png" as="image">
		<link rel="preload" href="images/Velociraptor/velociraptorcp.png" as="image">
	</head>

	<style>
		#lightboxImg:hover {
			filter: opacity(75%);
		}
	</style>

	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="index.html" class="logo"><strong>Richmond</strong> <span>Yang</span></a>
						<nav>
							<a href="#menu">Menu</a>
						</nav>
					</header>

				<!-- Menu -->
					<nav id="menu">
						<ul class="links">
							<li><a href="index.html">Home</a></li>
							<li><a href="art.html">Art</a></li>
							<li><a href="coding.html">Coding and Game Development</a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main" class="alt">

						<!-- One -->
							<section id="one">
								<div class="inner">
									<header class="major">
										<h1>Anisotropic Kuwahara Filter</h1>
									</header>
									<span class="image main"><img src="images/Kuwahara/lion_kernel10.png" alt="" /></span>
									<br>
									<p>This post-processing filter was made for the CS50 final project. I had become incredibly interested in graphics programming after watching YouTuber Acerola, and after watching his video on this shader, I wanted to make an implementation in Godot based on his implementation for Unity for my final project.</p>
									<p>Using papers linked in Acerola's video alongside information in the video itself and his implementation for Unity URP, I learned the fundamentals of shader programming, the concepts behind the Kuwahara shader, and converted the code in HLSL into a fragment shader in Godot Shading Language (language heavily based on GLSL).</p>	
									<p>All resources will be linked at the bottom of this page.</p>
									<p>The code first convolves pixels with the sobel filter to approximate the partial derivatives and thus gradient of the image. These are then outputted in a structure tensor.</p>
									<pre>
										<code>vec4 sobel(vec2 screen_size, vec2 uv)
{
	// Calculate Sobel to approximate structure tensor
	vec2 d = screen_size.xy;
	
	vec3 sobel_x = (
		1.0f * texture(_MainTex, uv + vec2(-d.x, -d.y)).rgb +
		2.0f * texture(_MainTex, uv + vec2(-d.x,  0.0)).rgb +
		1.0f * texture(_MainTex, uv + vec2(-d.x,  d.y)).rgb +
		-1.0f * texture(_MainTex, uv + vec2(d.x, -d.y)).rgb +
		-2.0f * texture(_MainTex, uv + vec2(d.x,  0.0)).rgb +
		-1.0f * texture(_MainTex, uv + vec2(d.x,  d.y)).rgb
		) / 4.0f;
	vec3 sobel_y = (
		1.0f * texture(_MainTex, uv + vec2(-d.x, -d.y)).rgb +
		2.0f * texture(_MainTex, uv + vec2( 0.0, -d.y)).rgb +
		1.0f * texture(_MainTex, uv + vec2( d.x, -d.y)).rgb +
		-1.0f * texture(_MainTex, uv + vec2(-d.x, d.y)).rgb +
		-2.0f * texture(_MainTex, uv + vec2( 0.0, d.y)).rgb +
		-1.0f * texture(_MainTex, uv + vec2( d.x, d.y)).rgb
		) / 4.0f;
		
	// Structure Tensor (4x4 matrix)
	return vec4(dot(sobel_x, sobel_x), dot(sobel_y, sobel_y), dot(sobel_x, sobel_y), 1.0);
}
										</code>
									</pre>
									<a href="images/Velociraptor/velociraptorcp.png" data-lightbox="creasepattern" data-title="Crease Pattern">
										<img id="lightboxImg" src="images/Velociraptor/velociraptorcp.png" alt="" style="display:block;width:70%; margin-left:auto; margin-right:auto;"/>
									</a>
									<br>
									<p>This structure tensor is then blurred to give smoother results and reduce noise in the partial derivatives.</p>
									<pre>
										<code>vec4 blur(vec4 tensor, vec2 uv, vec2 d)
{
	// Gaussian Blur
	int kernelRadius = 5;
	
	vec4 col = vec4(0.0);
	float kernelSum = 0.0;
	
	// Blur x pass
	for (int x = -kernelRadius; x <= kernelRadius; x++)
	{
		// Apply gaussian weights to current pixel color multiplied by tensor
		vec4 c = tensor * texture(_MainTex, uv + vec2(float(x), 0.0) * d.xy);
		float gauss = gaussian(2.0, float(x));
		
		// Return current pixel color multiplied by weight
		col += c * gauss;
		kernelSum += gauss;
	}
	
	// Normalize color
	col = col / kernelSum;
	
	// Blur y pass
	for (int y = -kernelRadius; y <= kernelRadius; y++)
	{
		// Apply gaussian weights to current pixel color multiplied by tensor
		vec4 c = tensor * texture(_MainTex, uv + vec2(0.0, float(y)) * d.xy);
		float gauss = gaussian(2.0, float(y));
		
		// Return current pixel color multiplied by weight
		col += c * gauss;
		kernelSum += gauss;
	}
	
	// Normalize color
	return vec4(col / kernelSum);
}
										</code>
									</pre>
									<a href="images/Velociraptor/origami_prototype.png" data-lightbox="draft" data-title="Draft">
										<img id="lightboxImg" src="images/Velociraptor/origami_prototype.png" style="display:block;width:70%; margin-left:auto; margin-right:auto;"/>
									</a>
									<br>
									<p>Final fold using Origamido paper and shaped with methyl cellulose.</p>
									<a href="images/Velociraptor/velociraptor.png" data-lightbox="final" data-title="Final Fold">
										<img id="lightboxImg" src="images/Velociraptor/velociraptor.png" alt="" style="display:block;width:70%; margin-left:auto; margin-right:auto;"/>
									</a>
									<br>
									<a href="images/Velociraptor/velociraptor_closeup.png" data-lightbox="closeup" data-title="Close Up">
										<img id="lightboxImg" src="images/Velociraptor/velociraptor_closeup.png" alt="" style="display:block;width:70%; margin-left:auto; margin-right:auto;"/>
									</a>
									<br>
									<p>The process of designing origami was very challenging, especially connecting the pieces and getting them to work together in a single square. I debated using a smaller grid and rearranging the arms so that they extending from the opposite corner of the paper and not adjacent to the jaw, but that ended up making the paper too short proportionally with the tail and legs. I hope to update the design so that its more efficient and lies fully flat without internat adjustments, alongside more proportionally accurate as the head in the final design turned out much larger than I had expected in proportion to the rest of the body. However, as my first attempt designing an origami, I'm especially pleased with how it came out in relation to how I had envisioned.</p>
								</div>
							</section>
					</div>
			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
			<script src="assets/js/lightbox-plus-jquery.js"></script>

	</body>
</html>